import { db } from '@ai-accountant/database';
import { createLogger } from '@ai-accountant/shared-utils';
import { TenantId } from '@ai-accountant/shared-types';
import { filingWorkflowService } from './filingWorkflows';
import { generateVATFiling } from './hmrc';
import { FilingType } from '@ai-accountant/shared-types';
import { randomUUID } from 'crypto';

const logger = createLogger('filing-calendar-scheduler');

export interface FilingCalendar {
  id: string;
  tenantId: TenantId;
  jurisdiction: string;
  filingType: string;
  frequency: 'monthly' | 'quarterly' | 'annually' | 'one_time';
  dueDate: Date;
  periodStart: Date | null;
  periodEnd: Date | null;
  autoGenerateDraft: boolean;
  daysBeforeDue: number;
  reminderDays: number[];
  draftGenerated: boolean;
  draftGeneratedAt: Date | null;
  filingId: string | null;
}

/**
 * Filing Calendar Scheduler (Chunk 2)
 * Generates filing drafts automatically based on calendar
 */
export class FilingCalendarScheduler {
  /**
   * Process calendar entries and generate drafts
   */
  async processCalendarEntries(): Promise<number> {
    const now = new Date();
    const cutoffDate = new Date(now);
    cutoffDate.setDate(cutoffDate.getDate() + 30); // Look ahead 30 days

    // Find calendar entries that need draft generation
    const result = await db.query<{
      id: string;
      tenant_id: string;
      jurisdiction: string;
      filing_type: string;
      frequency: string;
      due_date: Date;
      period_start: Date | null;
      period_end: Date | null;
      auto_generate_draft: boolean;
      days_before_due: number;
      draft_generated: boolean;
    }>(
      `SELECT * FROM filing_calendars
       WHERE auto_generate_draft = true
         AND draft_generated = false
         AND due_date BETWEEN $1 AND $2
         AND due_date - INTERVAL '1 day' * days_before_due <= $3`,
      [now, cutoffDate, now]
    );

    let generatedCount = 0;

    for (const row of result.rows) {
      try {
        await this.generateDraftForCalendar(row.id, row);
        generatedCount++;
      } catch (error) {
        logger.error('Failed to generate draft for calendar entry', {
          calendarId: row.id,
          error: error instanceof Error ? error : new Error(String(error)),
        });
      }
    }

    logger.info('Processed calendar entries', { total: result.rows.length, generated: generatedCount });
    return generatedCount;
  }

  /**
   * Generate draft filing for calendar entry
   */
  private async generateDraftForCalendar(
    calendarId: string,
    calendar: {
      id: string;
      tenant_id: string;
      jurisdiction: string;
      filing_type: string;
      frequency: string;
      due_date: Date;
      period_start: Date | null;
      period_end: Date | null;
    }
  ): Promise<void> {
    const periodStart = calendar.period_start || this.calculatePeriodStart(calendar.due_date, calendar.frequency);
    const periodEnd = calendar.period_end || this.calculatePeriodEnd(calendar.due_date, calendar.frequency);

    // Generate filing data based on type
    let filingData: Record<string, unknown>;
    let filingType: FilingType;

    if (calendar.filing_type === 'vat') {
      filingType = FilingType.VAT;
      filingData = await generateVATFiling(calendar.tenant_id, periodStart, periodEnd);
    } else if (calendar.filing_type === 'paye') {
      filingType = FilingType.PAYE;
      const { generatePAYEFiling } = await import('./payeCalculation');
      filingData = await generatePAYEFiling(calendar.tenant_id, periodStart, periodEnd);
    } else {
      throw new Error(`Unsupported filing type: ${calendar.filing_type}`);
    }

    // Create filing record
    const filingId = randomUUID();
    await db.query(
      `INSERT INTO filings (
        id, tenant_id, filing_type, status, period_start, period_end,
        filing_data, calculated_by, model_version, created_at, updated_at
      ) VALUES (
        $1, $2, $3, 'draft', $4, $5, $6::jsonb, 'system', 'v1', NOW(), NOW()
      )`,
      [
        filingId,
        calendar.tenant_id,
        filingType,
        periodStart,
        periodEnd,
        JSON.stringify(filingData),
      ]
    );

    // Create workflow
    await filingWorkflowService.createWorkflow(
      filingId,
      calendar.tenant_id,
      [],
      `Auto-generated draft for ${calendar.filing_type} filing due ${calendar.due_date.toISOString()}`
    );

    // Update calendar entry
    await db.query(
      `UPDATE filing_calendars
       SET draft_generated = true,
           draft_generated_at = NOW(),
           filing_id = $1,
           updated_at = NOW()
       WHERE id = $2`,
      [filingId, calendarId]
    );

    logger.info('Draft filing generated', { calendarId, filingId, filingType });
  }

  /**
   * Calculate period start based on due date and frequency
   */
  private calculatePeriodStart(dueDate: Date, frequency: string): Date {
    const start = new Date(dueDate);

    switch (frequency) {
      case 'monthly':
        start.setMonth(start.getMonth() - 1);
        start.setDate(1);
        break;
      case 'quarterly':
        start.setMonth(start.getMonth() - 3);
        start.setDate(1);
        break;
      case 'annually':
        start.setFullYear(start.getFullYear() - 1);
        start.setMonth(0);
        start.setDate(1);
        break;
      default:
        start.setDate(start.getDate() - 30);
    }

    return start;
  }

  /**
   * Calculate period end based on due date and frequency
   */
  private calculatePeriodEnd(dueDate: Date, frequency: string): Date {
    const end = new Date(dueDate);

    switch (frequency) {
      case 'monthly':
        end.setDate(0); // Last day of previous month
        break;
      case 'quarterly':
        end.setMonth(end.getMonth() - 1);
        end.setDate(0);
        break;
      case 'annually':
        end.setMonth(11);
        end.setDate(31);
        break;
      default:
        end.setDate(end.getDate() - 1);
    }

    return end;
  }

  /**
   * Create calendar entry
   */
  async createCalendarEntry(
    tenantId: TenantId,
    jurisdiction: string,
    filingType: string,
    frequency: 'monthly' | 'quarterly' | 'annually' | 'one_time',
    dueDate: Date,
    periodStart?: Date,
    periodEnd?: Date
  ): Promise<string> {
    const calendarId = randomUUID();

    await db.query(
      `INSERT INTO filing_calendars (
        id, tenant_id, jurisdiction, filing_type, frequency,
        due_date, period_start, period_end, auto_generate_draft,
        days_before_due, reminder_days, created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, true, 7,
        ARRAY[30, 14, 7, 1]::INTEGER[], NOW(), NOW()
      )`,
      [
        calendarId,
        tenantId,
        jurisdiction,
        filingType,
        frequency,
        dueDate,
        periodStart || null,
        periodEnd || null,
      ]
    );

    return calendarId;
  }

  /**
   * Get upcoming deadlines for tenant
   */
  async getUpcomingDeadlines(tenantId: TenantId, days: number = 30): Promise<FilingCalendar[]> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() + days);

    const result = await db.query<{
      id: string;
      tenant_id: string;
      jurisdiction: string;
      filing_type: string;
      frequency: string;
      due_date: Date;
      period_start: Date | null;
      period_end: Date | null;
      auto_generate_draft: boolean;
      days_before_due: number;
      reminder_days: number[];
      draft_generated: boolean;
      draft_generated_at: Date | null;
      filing_id: string | null;
    }>(
      `SELECT * FROM filing_calendars
       WHERE tenant_id = $1
         AND due_date BETWEEN NOW() AND $2
       ORDER BY due_date ASC`,
      [tenantId, cutoffDate]
    );

    return result.rows.map(row => ({
      id: row.id,
      tenantId: row.tenant_id,
      jurisdiction: row.jurisdiction,
      filingType: row.filing_type,
      frequency: row.frequency as FilingCalendar['frequency'],
      dueDate: row.due_date,
      periodStart: row.period_start,
      periodEnd: row.period_end,
      autoGenerateDraft: row.auto_generate_draft,
      daysBeforeDue: row.days_before_due,
      reminderDays: row.reminder_days,
      draftGenerated: row.draft_generated,
      draftGeneratedAt: row.draft_generated_at,
      filingId: row.filing_id,
    }));
  }
}

export const filingCalendarScheduler = new FilingCalendarScheduler();

// Background job to process calendar entries (run daily)
if (process.env.NODE_ENV !== 'test') {
  setInterval(() => {
    filingCalendarScheduler.processCalendarEntries().catch(error => {
      logger.error('Failed to process calendar entries', error instanceof Error ? error : new Error(String(error)));
    });
  }, 24 * 60 * 60 * 1000); // 24 hours
}
